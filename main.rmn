->> std->networking->TCP,IP,Routing as rt
->> DSA->stack,heap,queue,hash->heapify as add,
                                dequeue as dq, 
                                pop, deHash
->> Tensorflow as tf


""" for documenting functions, objects, libraries, ... """


fun Main

    str name // uninitialized variable is not allowed
    input str name // initialize var same when in use
    log "Hello world, my name is #name \#climateChange"

    // do stuff
    // it can execute like JS & PY(notebook by notebook) or like C,C++,Rust(from Main)


global const int PI <- 3.14159

static int count <- 0

ato x <- anyType
mut ato x <- anyType // mut allows variable mutability
int x <- -1
[int] x <- [-23,54] // array of int, arrays are zero index based
mut [int] x <- [-23,54]
[[int]] x <- [[213,444,2],[134,74]] // multi dimensional array of int
mut int x <- -1
unt x <- 1 // only positive nums
bol x <- false
mut bol x <- false
str x <- "String"
chr x <- 'C'
flt x <- 12.34
flt ðŸ¤£ <- 12.34 // UTF-8 encoding
// instead of null
opt x <- x.failure
opt x <- x.success

// pointers and addresses
//


logical operators
    and , in other PLs &&
    or  , in other PLs ||
    ==
    !=
    <=
    >=
    <
    >
    // bitwise
    | or
    & and
    ^ XOR

// bitwise shift
    <<
    >>



#attributeName
#test

loop [n = iter count(optional)]
    if n [condition]
        break
    elsif [condition]
        continue
    else
        return 0




loop index in collection
    // element of collection

loop [condition]
    // do stuff
    [pattern] ? [do if true] : [do if false]
    continue
    break


loop once
    // iterate once 
[condition]


enum name
    x
    y: 12
    z

name->x


match pattern
    x-> /*
            do more stuff
            do more stuff
        */

    y-> // do stuff
    z-> // do stuff




// function name must start with lowercase, except Main function
// the function body must have one line space from the signature

fun name(arg: type , arg2: type = defaultVal , arg3: type ) -> returnType

    // do fun stuff
    return x


// if function returns nothing, the returnType is empty
fun name(arg: type , arg2: type = defaultVal , arg3: type )

    // do fun stuff





trait
    sortable <- int,unt,char,flt
    addable <- int, unt, flt
    sexy <- ptr,adr
    
    fun bubbleSort|T: sortable|(arr: [T]) -> [T]
        
        unt n <- len(arr)
        loop i in arr:
            loop j in range(0..n-i-1):
                if arr[j] > arr[j+1]:
                    swap(arr[j], arr[j+1])

        

fun name|T: sortable,addable | U: sexy | ( arg: T, arg2: U ) -> U

    // do stuff
    return U



scope name 
    // scope does the same as namespaces in C++, to avoid naming conflicts&...
    // and the mod in rust, module...




obj name
    constructor()

        // do initializing stuff
    deConstructor()

        // do ending stuff

    pub :
        bol isAlive 
        int age 
        str name 
        fun += 
        fun %= 
        fun *= 
        fun /= 
        fun -= 
        fun getOld()

            age += 1

        fun getYoung() 

            age -= 1

        fun changeName(name: str):

            name <- name // can differentiate by syntax highlighting

        fun revealId()

            log securityNum
            log isSpy
            log grade

    int securityNum
    bol isSpy
    chr grade

    inherits
        from baseObj4
        from baseObj1
            not variableName, secondVarName
            override variableName <- 43
            override base1func(args)
                // stuff
        from baseObj2


obj | T: sortable,sexy | V: addable | genericName 
    constructor(are: T, arg2: U)

        // do initializing stuff

    deConstructor()

        // do ending stuff


ato sayCrap <- x >= 12 ? log "Fuck" : "Shit"



// is keyword assigns value to object members
heapy obj name <- name is "Raman",
                  age is 22, 
                  isAlive is true 

std->baseObj.funName() //routing syntaxes

heap x <- 1,3,3,8
stack x <- 2,0,5,5
queue x <- 4,3,5,2
x.pop()
x.dq()
x.heapify()