A SHARP TOOL FOR SHARP ENGINEERS

#the grand rule of ALL is "do not make it harder to be simpler"
make software as simple as possible, free the resources to build greatness not fix shit bugs
focus is on great software, train great programmers to write great programs
beginners can write standard pseudo code the execute it with the NN, path to greatness
continues by coding in RMN(a heart surgeon(specialist) mos study body anatomy first(generalist))
professionals must not do beginner things and beginners must not do professional things
learn to use hammer before nail gun

------------ GOALS ---------------




--------------FEATURES----------------
tip = heavy features will be implemented in the SIDE to let the Core RMN stay as light as C
# compiler is as good as the input source code, there must be rules to force great software

# has a low level VM that executes .ll file, generated by the compiler(front and mid) from source code(extract the LLVM backend
 as a VM),and the option to direct compile(front, mid, backend together). so it has byte code and .exe. the VM has a GC

# performance and memory safety. does not have runtime,native support for GPU execution, native support for 
  parallel and distributed computing no GC memory safety: data ownership, data lifetime, memory sandbox, ARC

# UML prototyping
# favors writing reusable code
# strong and static type system
# (low to high level) support for distributed computing and GPU computing
# HACK mode(fast demo, beginner, only .stdpsd) and Production mode(safe, fast ,.rmn ...)
# support : imperative(procedural , OOP) and declarative(functional, logic, mathematical, reactive)
# use UTF-8 
# has a project map: import trees and ... to understand the proj struct
# native TDD approach
# collections(arrays,tuples,...) functionalities of julia
